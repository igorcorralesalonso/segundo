# -*- coding: utf-8 -*-

"""
Copyright (c) Telefonica Digital.
ElevenPaths QA Team <qateam@11paths.com>
"""

import base64
import codecs
import collections
import json
import logging
import os
import re
from copy import deepcopy
from os import listdir
from os.path import isfile, isdir, join

from yaml import load

from toolium11paths.utils.dataset import prepare_param

__logger__ = logging.getLogger(__name__)

# Loaded configuration. Module variable with all loaded properties: JSON
config = None
toolium_config = None

# Loaded language properties as Python Dict
language_prop_list = None
language = None  # es, en, ...

# Used in base64 as relative path
base64_path = u'resources/'


def get_properties_file(from_path, filename):
    for root, dirs, files in os.walk(from_path):
        if filename in files:
            return os.path.join(root, filename)
    else:
        raise IOError("No such file or directory: '%s'" % filename)


def load_project_properties(from_path, config_properties_filename):
    """
    Parses the JSON configuration file located in the conf folder and
    stores the resulting dictionary in the config global variable.
    :param from_path: Path to search properties file to be loaded.
    :param config_properties_filename: Name of properties file.
    """
    global config
    json_file = get_properties_file(from_path, config_properties_filename)
    config = get_properties_json(json_file)
    __logger__.debug("Properties loaded: %s", config)


def get_properties_json(json_file):
    """
    Parses the JSON configuration file
    :param json_file: Path to properties file to be loaded.
    :returns: dict with loaded properties
    """
    __logger__.info("Loading project properties from %s", json_file)
    try:
        with open(json_file) as config_file:
            try:
                main_config = json.load(config_file)
                if 'base_properties_file' in main_config:
                    base_json_file = os.path.join(os.path.dirname(json_file), main_config['base_properties_file'])
                    base_config = get_properties_json(base_json_file)
                    dict_merge(base_config, main_config)
                    main_config = base_config
            except Exception, e:
                __logger__.error('Error parsing config file: %s' % e)
                raise e
    except IOError, e:
        __logger__.error('%s properties file CANNOT be opened: %s', json_file, e)
        raise e
    return main_config


def load_message_properties(lang, lang_dir):
    """
    Loads all lang properties for the files located in the given lang_dir.
    File format to load: *.yaml
    :param lang: (string) Language property to load text messages from files.
    :param lang_dir: (string) Dir where the lang files are located
    :return: None. The loaded lang properties will be saved in the global var of this file: language_prop_list
    """

    __logger__.info("Language set to '%s'", lang)
    __logger__.info("Loading all language files from '%s'", lang_dir)
    if isdir(lang_dir):
        file_list = [join(lang_dir, f) for f in listdir(lang_dir) if isfile(join(lang_dir, f)) and
                     f.endswith(".yaml")]
        __logger__.debug("Language properties file list: '%s'", file_list)

        global language_prop_list, language

        language = lang
        language_prop_list = dict()
        for file in file_list:
            # Open the file with the correct encoding
            with codecs.open(file, 'r', encoding='utf-8') as f:
                language_prop_list.update(load(f))
        __logger__.debug("Language properties loaded for: '%s'", language_prop_list.keys())
    else:
        __logger__.warn("Dir with language property files not found.")


def load_toolium_properties(toolium_config_object):
    """
    Copy toolium config to be used later in prepare_param method
    :param toolium_config_object: configuration object with toolium properties
    """
    global toolium_config
    toolium_config = toolium_config_object


def get_message_property(key_string):
    """
    Gets the given property as String separated by points: "home.button.send"
    :param key_string: (string) Chain of keys to get
    :return: Value of the given property chain in the specified language
    """

    key_list = key_string.split(".")
    language_props_copy = deepcopy(language_prop_list)
    try:
        for key in key_list:
            language_props_copy = language_props_copy[key]

        __logger__.info("Mapping language param '%s' to its configured value '%s'", key_string, language_props_copy)
    except KeyError as e:
        __logger__.error("Mapping chain '%s' not found in the language properties file", key_string)
        raise e

    return language_props_copy[language]


def set_base64_path(path):
    """
    define the base64 relative path
    :param path: realive path
    """
    global base64_path
    base64_path = path


def convert_file_to_base64(path_file):
    """
    convert the file to base64. Allowed format: Ex: [BASE64:files/others/document.pdf]
    Notice The path is relative of the resources folder into the project
    :param path_file: path and file.
    :return: String
    """
    temp = [os.getcwd()] + (base64_path + path_file).split("/")
    file_name = os.path.join(*temp)
    try:
        with open(file_name, "rb") as temp_file:
            file_content = base64.b64encode(temp_file.read())
    except Exception, e:
        raise Exception(" ERROR - converting the \"%s\" file to Base64...\n:    %s" % (file_name, e))
    return file_content


def _is_matches(param):
    """
    Checks if the given param should be loaded from:
       - Environment Configuration File Format: [CONF:home.button.label]
       - Language Configuration File. Format: [LANG:home.button.label]
       - A file and converted in Base64. Format: [BASE64:path/file]
    :param param: Parameter to check its value.
    :return: returning a tuple with the type and a match object, or None if no match was found.
    """
    items = ["CONF", "LANG", "BASE64", "TOOLIUM", "CONTEXT", "FILE"]
    for item in items:
        temp = re.match("\[%s:(.*)\]" % item, param)
        if temp:
            return item, temp
    return None, None


def map_one_param(param_value, context=None):
    """
    Analyzes the given parameter value and find out its real value into the loaded environment configuration file or
    language configuration file.
    :param param_value: Parameter value. If it should be replaced by its real value into configuration file, when
    the format is something like this: [CONF:services.vamps.user] or [LANG:home.button.label].
    Available parameters:
        [FILE:path/to/file] Returns the content of the specified file
    :return: Real parameter value (unicode). If the param value does not suit this format,
    the returned param value is the same as the given one.
    """
    if not isinstance(param_value, basestring):
        return param_value

    item, match_group = _is_matches(param_value)
    if match_group:
        if item == "CONF":
            return map_json_param(match_group.group(1))
        elif item == "LANG":
            return get_message_property(match_group.group(1))
        elif item == "BASE64":
            return convert_file_to_base64(match_group.group(1))
        elif item == "TOOLIUM":
            return map_toolium_param(match_group.group(1))
        elif item == "CONTEXT" and context and context.storage:
            return get_value_from_context(context, match_group.group(1))
        elif item == "FILE":
            file_path = match_group.group(1)

            if not os.path.exists(file_path):
                raise Exception(' ERROR - Cannot read file "{filepath}". Does not exist.'.format(filepath=file_path))

            with open(file_path, 'r') as f:
                return f.read()
    else:
        return param_value


def map_param(param_value, context=None):
    """
    Analyzes the given parameter value and find out its real value into the loaded environment configuration file or
    language configuration file. The parameter could be a any combination of text any configuration parameters.
    :param param_value: Parameter value. If it should be replaced by its real value into configuration file, when
    the format is something like this: [CONF:services.vamps.user] or [LANG:home.button.label].
    :return: Real parameter value (unicode). If the param value does not suit this format,
    the returned param value is the same as the given one.
    :param param_value:
    :return:
    """

    # The parameter is not a string
    if not isinstance(param_value, basestring):
        return param_value

    conf_regex = "[\[CONF:|\[LANG:|\[BASE64:|\[TOOLIUM:|\[CONTEXT:|\[FILE:][a-zA-Z\.\:\/\_\-\ 0-9]*\]"
    conf_expressions = re.compile(conf_regex)

    # The parameter is just one config value
    if conf_expressions.split(param_value) == ['', '']:
        return map_one_param(param_value, context)

    # The parameter is a combination of text and configuration parameters.
    for config_subs in conf_expressions.findall(param_value):
        param_value = param_value.replace(config_subs, map_one_param(config_subs, context))
    return param_value


def table_set_map_params(table, context=None, datatypes=True):
    """
    Analyzes the values of a table from a step and replace the placeholders for configuration-based or
    special values with the appropriate content.
    :param table: Table with parameter values that can contain configuration parameters or special values. E.g.
    Scenario: Example of scenario
      Given Example of step
       | eg_param       | [LANG:flag]   |
       | [CONF:xxx.yyy] | [TRUE]        |
      When ...
      Then ...
    :param context: Current context if needed.
    :param datatypes: Infere datatypes (real type of the table fields).
    :return: A list of dictionaries with the content of the table already parsed.
    """
    if table is None:
        return None

    for i, heading in enumerate(table.headings):
        parsed_value = prepare_param(map_param(heading, context), datatypes)
        table.headings[i] = unicode(parsed_value)

    parsed_table = []
    for row in table:
        parsed_row = {}
        for i, cell in enumerate(row.cells):
            parsed_value = prepare_param(map_param(cell, context), datatypes)
            parsed_row[table.headings[i]] = parsed_value
            row.cells[i] = unicode(parsed_value)  # this is used to print the replaced values during step execution
        parsed_table.append(parsed_row)
    return parsed_table


def map_json_param(param_value, config_json=None):
    """
    Analyzes the given parameter value and find out its real value into the loaded environment configuration file or
    json structure.
    :param param_value: Parameter value. If it should be replaced by its real value into configuration file or
    json structure, when the format is something like this: [CONF:services.vamps.user] or "service.vamps.user", when
    I want to access to these properties:
        {
          "services":{
            "vamps":{
              "user": "cyber-sec-user@11paths.com",
              "password": "MyPassword"
            }
          }
        }
    :param config_json: (dict) Loaded configuration file (environment properties)
    :return: Real parameter value. In this case, the string "cyber-sec-user@11paths.com". If the param value
    does not suit this format, the returned param value is the same as the given one.
    """

    if not config_json:
        config_json = config

    properties_list = param_value.split(".")
    aux_config_json = deepcopy(config_json)
    try:
        for property in properties_list:
            if type(aux_config_json) is list:
                aux_config_json = aux_config_json[int(property)]
            else:
                aux_config_json = aux_config_json[property]

        __logger__.info("Mapping param '%s' to its configured value '%s'", param_value, aux_config_json)
    except KeyError as e:
        __logger__.error("Mapping chain not found in the configuration properties file or given json structure.")
        raise e
    except ValueError as details_ValueError:
        __logger__.error("Specified value is not a valid index.")
        raise details_ValueError
    except IndexError as details_IndexError:
        __logger__.error("Mapping index not found in the configuration properties file or given json structure.")
        raise details_IndexError
    return os.path.expandvars(aux_config_json) if type(aux_config_json) not in [int, bool, float] else aux_config_json


def map_toolium_param(param_value):
    """
    Analyzes the given parameter value and find out its real value into the loaded toolium configuration file
    :param param_value: Parameter value. If it should be replaced by its real value into configuration file, when
    the format is something like this: [TOOLIUM:TestExecution_environment], when
    [TestExecution]
    environment: QA
    :return: Real parameter value. In this case, the string "QA".
    """

    try:
        section = param_value.split("_", 1)[0]
        property_name = param_value.split("_", 1)[1]
    except IndexError as e:
        __logger__.error("Invalid format in Toolium config param '%s'. Valid format: 'Section_property'.", param_value)
        raise e

    try:
        mapped_value = toolium_config.get(section, property_name)
        __logger__.info("Mapping Toolium config param '%s' to its configured value '%s'", param_value, mapped_value)
    except Exception as e:
        __logger__.error("Toolium config param '%s' not found in Toolium config file.", param_value)
        raise e
    return mapped_value


def get_value_from_context(context, param_value):
    if not context.storage[param_value]:
        __logger__.error("The requested key is not present in the context storage")
        raise IndexError
    return context.storage[param_value]


# Copied from https://gist.github.com/angstwad/bf22d1822c38a92ec0a9
def dict_merge(dct, merge_dct):
    """ Recursive dict merge. Inspired by :meth:``dict.update()``, instead of
    updating only top-level keys, dict_merge recurses down into dicts nested
    to an arbitrary depth, updating keys. The ``merge_dct`` is merged into
    ``dct``.
    :param dct: dict onto which the merge is executed
    :param merge_dct: dct merged into dct
    :return: None
    """
    for k, v in merge_dct.iteritems():
        if (k in dct and isinstance(dct[k], dict)
                and isinstance(merge_dct[k], collections.Mapping)):
            dict_merge(dct[k], merge_dct[k])
        else:
            dct[k] = merge_dct[k]
