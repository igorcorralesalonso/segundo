# -*- coding: utf-8 -*-

"""
Copyright (c) Telefonica Digital.
ElevenPaths QA Team <qateam@11paths.com>
"""

import json
import uuid
import re
import datetime

"""
Original file from Telefónica I+D:
    https://github.com/telefonicaid/lettuce-tools/blob/master/lettuce_tools/dataset_utils/dataset_utils.py

dataset_utils module contains:
    - A dataset manager to prepare test data:
        * generate_fixed_length_params: Transforms the '[LENGTH]' param value to a valid length.
        * remove_missing_params: Remove parameters with value '[MISSING]'
        * infere_datatypes: Inferes type of parameters to convert them in the suitable var type
"""

__author__ = "Telefónica I+D, qateam@11paths.com"
__copyright__ = "Copyright 2015"
__license__ = " Apache License, Version 2.0"


def prepare_data(data):
    """
    Generate a fixed length data for elements tagged with the text [LENGTH]
    Removes al the data elements tagged with the text [MISSING_PARAM]
    Transformes data from string to primitive type
    :param data: hash entry
    :return cleaned data
    """
    try:
        data = generate_fixed_length_params(data)
        data = remove_missing_params(data)
        data = infere_datatypes(data)
        return data
    except:
        return None


def prepare_param(param, datatypes=True, language="es"):
    """
    Available replacements:
        [LENGTH] Generate a fixed length data for elements
        [MISSING_PARAM] Remove the param from the Dataset
        [EMPTY] Empty string
        [B] Add Blank space if  in the given param
        [RANDOM] Generate random value
        [DATETIME] Add a timestamp
        [NOW] Similar to DATETIME without milliseconds
        [NOW + 2 DAYS] Similar to NOW but two days later
        [NOW - 1 MINUTES] Similar to NOW but one minute earlier
    This functions transforms data from string to primitive type if datatypes is True (default behaviour)
    :param param: Test parameter
    :param datatypes: Infere datatypes (real type of the given param)
    :return data with the correct replacements
    """

    if not isinstance(param, basestring):
        return param

    date_format = '%d/%m/%Y %H:%M:%S' if language == 'es' else '%Y/%m/%d %H:%M:%S'
    date_day_format = '%d/%m/%Y' if language == 'es' else '%Y/%m/%d'
    date_matcher = re.match('\[(NOW|TODAY)\s*([\+|-]\s*\d+)\s*(\w+)\s*\]', param)

    if "[MISSING_PARAM]" in param:
        new_param = None
    elif "[EMPTY]" in param:
        new_param = ""
    elif "[B]" in param:
        new_param = param.replace("[B]", " ")
    elif "[RANDOM]" in param:
        # Avoid to use infere_datatypes(), random value must be always a string
        return param.replace("[RANDOM]", uuid.uuid4().get_hex()[0:8])
    elif "[DATETIME]" in param:
        # Avoid to use infere_datatypes(), datetime value must be always a string
        return param.replace("[DATETIME]", str(datetime.datetime.utcnow()))
    elif "[NOW]" in param:
        return param.replace("[NOW]", str(datetime.datetime.utcnow().strftime(date_format)))
    elif "[TODAY]" in param:
        return param.replace("[TODAY]", str(datetime.datetime.utcnow().strftime(date_day_format)))
    elif date_matcher and len(date_matcher.groups()) == 3:
        configuration = dict([(date_matcher.group(3).lower(), int(date_matcher.group(2)))])

        reference_date = datetime.datetime.utcnow() if date_matcher.group(1) == 'NOW' else datetime.datetime.utcnow().date()
        replace_value = reference_date + datetime.timedelta(**configuration)
        return replace_value.strftime(date_format)
    else:
        new_param = generate_fixed_length_param(param)

    return infere_datatypes(new_param) if datatypes else new_param


def remove_missing_params(data):
    """
    Removes all the data elements tagged with the text [MISSING_PARAM]
    :param data: Lettuce step hash entry
    :return data without not desired params
    """
    try:
        for item in data.keys():
            if "[MISSING_PARAM]" in data[item]:
                del(data[item])
    finally:
        return data


def generate_fixed_length_param(param):
    """
    Generate a fixed length param if the elements matches the expression
    [<type>_WITH_LENGTH_<length>]. E.g.: [STRING_WITH_LENGTH_15]
    :param param: Lettuce param
    :return param with the desired length
    """
    try:
        if "_WITH_LENGTH_" in param:
            if "_ARRAY_WITH_LENGTH_" in param:
                seeds = {'STRING': 'a', 'INTEGER': 1}
                seed, length = param[1:-1].split("_ARRAY_WITH_LENGTH_")
                param = list(seeds[seed] for x in xrange(int(length)))
            elif "JSON_WITH_LENGTH_" in param:
                length = int(param[1:-1].split("JSON_WITH_LENGTH_")[1])
                param = dict((str(x), str(x)) for x in xrange(length))
            else:
                seeds = {'STRING': 'a', 'INTEGER': "1"}
                # The chain to be generated can be just a part of param
                start = param.find("[")
                end = param.find("]")
                seed, length = param[start + 1:end].split("_WITH_LENGTH_")
                generated_part = seeds[seed] * int(length)
                placeholder = "[" + seed + "_WITH_LENGTH_" + length + "]"
                param = param.replace(placeholder, generated_part)
                if seed is "INTEGER":
                    param = int(param)
    finally:
        return param


def generate_fixed_length_params(data):
    """
    Generate a fixed length data for the elements that match the expression
    [<type>_WITH_LENGTH_<length>]. E.g.: [STRING_WITH_LENTGH_15]
    :param data: hash entry
    :return data with the desired params with the desired length
    """
    try:
        for item in data.keys():
            data[item] = generate_fixed_length_param(data[item])
    finally:
        return data


def infere_datatypes(data):
    """
    Process the input data and replace the values in string format with the
    the appropriate primitive type, based on its content
    :param data: list of items, dict of items or single item
    :return processed list of items, dict of items or single item
    """

    """ Separate the process of lists, dicts and plain items"""
    try:

        if isinstance(data, dict):  # dict of items
            for key in data:
                data[key] = _get_item_with_type(data[key])

        elif isinstance(data, list):  # list of items
            for index in range(len(data)):
                data[index] = _get_item_with_type(data[index])

        else:  # single item
            data = _get_item_with_type(data)
    finally:
        return data


def _get_item_with_type(data):
    """
    Transform data from string to primitive type
    :param data: Data to be transformed
    :return data with the correct type
    """
    if "[TRUE]" in data:  # boolean (json boolean)
        data = True
    elif "[FALSE]" in data:  # boolean (json boolean)
        data = False
    elif "[NULL]" in data:  # None (json null)
        data = None
    elif data.startswith("[") and data.endswith("]") \
            or data.startswith("{") and data.endswith("}"):  # [] => list (json array) || {} =>  dict (json object)
        data = json.loads(data)
    else:
        try:  # maybe an int (json number)
            data = int(data)
        except:
            try:  # maybe a float (json number)
                data = float(data)
            except:
                pass  # if no condition matches, leave the data unchanged
    return data
