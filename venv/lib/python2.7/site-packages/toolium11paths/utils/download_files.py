# -*- coding: utf-8 -*-

"""
Copyright (c) Telefonica Digital.
ElevenPaths QA Team <qateam@11paths.com>
"""

import difflib
import filecmp
import os
import time
import urllib
from lxml import html

from toolium11paths.driver_wrappers_pool import DriverWrappersPool

DOWNLOADS_SERVICE_PORT = 8001
DOWNLOADS_FOLDER = 'downloads'


def get_download_directory_base(context):
    """
    Get base folder to download files
    :param context: behave context
    :returns: base folder
    """
    if context.download_directory is None:
        base = None
    elif context.driver_wrapper.config.getboolean_optional('Server', 'enabled'):
        try:
            platform = context.driver_wrapper.config.get('Driver', 'type').split('-')[3]
        except IndexError:
            platform = 'linux'
        if platform.lower().startswith('win'):
            # Windows node
            base = 'C:\\tmp\\%s\\' % DOWNLOADS_FOLDER
        else:
            # Linux or Mac node
            base = '/tmp/%s/' % DOWNLOADS_FOLDER
    else:
        # Local folder
        destination_folder = os.path.join(DriverWrappersPool.output_directory, DOWNLOADS_FOLDER, '')
        if not os.path.exists(destination_folder):
            os.makedirs(destination_folder)
        base = str(destination_folder)
    return base


def get_downloaded_file_path(context, file_name):
    """
    Get local downloaded file path and retrieve remote file if necessary
    :param context: behave context
    :param file_name: downloaded file name
    :returns: local file path
    """
    if context.driver_wrapper.remote_node:
        downloaded_file = retrieve_remote_downloaded_file(context, file_name)
    else:
        downloaded_file = os.path.join(context.download_directory_base, context.download_directory, file_name)
    return downloaded_file


def retrieve_remote_downloaded_file(context, filename, destination_filename=None):
    """
    Retrieves a file downloaded in a remote node and saves it in the output folder
    :param context: behave context
    :param filename: downloaded file
    :param destination_filename: local destination name
    :returns: destination file path
    """
    destination_filepath = None
    if context.download_directory is not None and context.driver_wrapper.config.getboolean_optional('Server',
                                                                                                    'enabled'):
        url = _get_download_directory_url(context)
        file_url = '{url}/{filename}'.format(url=url, filename=filename)

        destination_folder = os.path.join(DriverWrappersPool.output_directory, DOWNLOADS_FOLDER,
                                          context.download_directory)
        if not os.path.exists(destination_folder):
            os.makedirs(destination_folder)
        destination_filename = destination_filename if destination_filename else filename
        destination_filepath = os.path.join(destination_folder, destination_filename)
        context.logger.info("Retrieving downloaded file from '%s' to '%s'", file_url, destination_filepath)
        urllib.urlretrieve(file_url, destination_filepath)
    return destination_filepath


def get_downloaded_files_list(context):
    if context.download_directory is not None and context.driver_wrapper.config.getboolean_optional('Server',
                                                                                                    'enabled'):
        url = _get_download_directory_url(context)

        context.logger.info("Getting downloads list from '%s'", url)

        content = urllib.urlopen(url).read()

        return html.fromstring(content).xpath('//li/a/text()')

    destination_folder = os.path.join(DriverWrappersPool.output_directory, DOWNLOADS_FOLDER, context.download_directory)

    return os.listdir(destination_folder)


def _get_download_directory_url(context):
    remote_node = context.driver_wrapper.remote_node
    # Workaround downloading from Mac in 11PATHS
    if context.driver_wrapper.config.get_optional('Capabilities', 'applicationName') == '11PATHS' \
            and remote_node == '10.95.192.102':
        remote_node = '172.16.0.81'

    url = 'http://{}:{}/{}'.format(remote_node, DOWNLOADS_SERVICE_PORT, context.download_directory.replace('\\', '/'))

    return url


def compare_downloaded_file(context, file_name, expected_folder, max_wait):
    """
    Compare downloaded file with the expected file
    :param context: behave context
    :param file_name: downloaded file
    :param expected_folder: folder with expected files
    :param max_wait: max time to wait
    """
    # Get downloaded file and compare with expected file
    template_file = os.path.join(os.getcwd(), expected_folder, file_name)
    start_time = time.time()
    while time.time() < start_time + max_wait:
        downloaded_file = get_downloaded_file_path(context, file_name)
        try:
            equals = filecmp.cmp(template_file, downloaded_file)
        except Exception:
            # File not found
            equals = False
        if equals:
            break
        time.sleep(1)
    end_time = time.time()

    # Show different lines in txt files
    delta = ''
    if not equals and file_name.endswith('.txt'):
        with open(downloaded_file) as downloaded, open(template_file) as template:
            diff = difflib.ndiff(downloaded.readlines(), template.readlines())
            delta = ''.join(x[2:] for x in diff if x.startswith('- '))
            delta = ':\n%s' % delta

    assert equals, ('The downloaded file "%s" is not equal to the expected file "%s" %s' % (
        file_name, os.path.join(expected_folder, file_name), delta))
    context.logger.debug('File downloaded in %f seconds', end_time - start_time)
