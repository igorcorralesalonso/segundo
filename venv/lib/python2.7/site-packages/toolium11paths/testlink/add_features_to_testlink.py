#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Copyright (c) Telef√≥nica Digital.
# CDO QA Team <qacdo@telefonica.com>

import logging
import logging.config
import os
import re
from collections import OrderedDict

import requests
import urllib3
from toolium.config_parser import ExtendedConfigParser

from toolium11paths.behave.environment_project_structure import (CONFIG_PROPERTIES_DIR, CONFIG_PROPERTIES_CONF,
                                                                 CONFIG_PROPERTIES_ENVIRONMENT,
                                                                 CONFIG_PROPERTIES_LANG_DIR)
from toolium11paths.behave.feature_parser import FeatureParser
from toolium11paths.utils.configuration import _is_matches, get_message_property
from toolium11paths.utils.configuration import load_project_properties, load_message_properties

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

URL_ESCAPE_CHARACTERS = {
    '#': '%23',
    '&': '%26',
    ';': '%3B'
}

ERROR_BEHAVE_PATTERN = u'ConfigError:'
EXCEPTION_BEHAVE_VALUE = u'Exception ValueError'

EXT_ORG = ".feature"
EXT_END = "-with_ids.feature"
TESTLINK_URL = "https://qacdo.e-paths.com/testlinkconnector"
GET_PATH_ADD = "?project_name=%s&operation=add&ts_name=%s&tc_name=%s&author=%s&steps=%s&executiontype=%s"
GET_PATH_UPDATE = "?project_name=%s&tc_id=%s&operation=update&tc_name=%s&author=%s&steps=%s&executiontype=%s"


def common_log(out_msg):
    print(out_msg)
    logging.info(out_msg)


def check_file(name_file):
    """
    Check if the file exists
    :param name_file: name file
    :return: True of False
    """
    if os.path.exists(name_file):
        return True
    else:
        logging.error("File {} not found".format(name_file))
        print("File {} not found".format(name_file))
        return False


def logger_ordered_dict(my_dict):
    for item in my_dict:
        logging.debug(item)


def parse_feature_execution(feature_file, language):
    """
    Parse feature file
    :param feature_file: feature file path
    :param language: LANG parameters will be translated to this language
    :returns: scenarios list
    """
    if not check_file(feature_file):
        exit(0)
    cmd = os.popen("behave -ds \"%s\"" % feature_file)
    feature = cmd.readlines()

    if feature[0].startswith(ERROR_BEHAVE_PATTERN) or feature[0].startswith(EXCEPTION_BEHAVE_VALUE):
        print("Executing behave -d %s" % feature_file)
        print(feature)
        logging.debug("Executing behave -d %s" % feature_file)
        logging.error(feature)
        exit(-1)

    # Translate LANG parameters in each step
    if language:
        load_config(language)
        feature = [translate_language_value(line) for line in feature]

    # Extract scenarios from feature
    scenarios = get_scenarios(feature)
    return scenarios


def translate_language_value(param_value):
    """
    Analyzes the given parameter value and find out its real value into the language configuration file.
    Created from toolium11paths map_param method.
    :param param_value: Parameter value, i.e. [LANG:home.button.label]
    :returns: Real parameter value (unicode).
    """
    conf_regex = "[\[LANG:][a-zA-Z\.\:\/\_\-\ 0-9]*\]"
    conf_expressions = re.compile(conf_regex)

    # The parameter is a combination of text and configuration parameters.
    for config_subs in conf_expressions.findall(param_value):
        item, match_group = _is_matches(config_subs)
        try:
            mapped_param = get_message_property(match_group.group(1)) if match_group and item == "LANG" else config_subs
        except KeyError:
            mapped_param = config_subs
        # Yaml lists are truncated to avoid error uploading features to testlink
        if isinstance(mapped_param, list):
            if len(mapped_param) > 5:
                mapped_param = ', '.join(mapped_param[:4]) + ', ... {} more'.format(len(mapped_param) - 4)
            else:
                mapped_param = ', '.join(mapped_param)
        param_value = param_value.replace(config_subs, unicode(mapped_param))
    return param_value


def load_config(language):
    """
    Load project configuration for a specific environment
    :param language: language to get localized properties
    """
    # Get environment from toolium.cfg
    config_file_path = os.path.join(CONFIG_PROPERTIES_DIR, CONFIG_PROPERTIES_CONF)
    config = ExtendedConfigParser.get_config_from_file(config_file_path)
    config.update_properties(os.environ)
    environment = config.get_optional('TestExecution', 'environment', 'QA').lower()

    # Load environment variables
    load_project_properties(CONFIG_PROPERTIES_DIR, CONFIG_PROPERTIES_ENVIRONMENT.format(env=environment))

    # Load language properties from files. Default: ES
    load_message_properties(language, CONFIG_PROPERTIES_LANG_DIR)


def add_actions(action_name, actions, scenario_list, feature, scenario):
    """
    Append before/after pre-defined actions in the feature description
    :param action_name: action name
    :param actions: acion dict with all actions pre-defined
    :param scenario_list: step list associated to a scenario
    :param feature: feature name
    :param scenario: scenario name
    :return: List
    """
    for step in actions[action_name]:
        scenario_list[feature][scenario]["steps"].append(step)
    return scenario_list


def get_scenarios(result_feature_execution):
    """
    Get features, scenarios and steps from execution log
    :param result_feature_execution: Execution log
    :return: OrderedDict()
    """
    pattern = re.compile("Scenario|Feature|Given|When|Then|And|But|@|\|")
    gherkin_list = [line.strip() for line in result_feature_execution
                    if pattern.search(line)]

    logging.debug("......init gherkin_list......")
    for item_gherkin in gherkin_list:
        logging.debug(item_gherkin)
    logging.debug("......end gherkin_list.......\n")

    scenarios = OrderedDict()

    action_name = None
    actions = {u'actions before the feature': [],
               u'actions before each scenario': [],
               u'actions after each scenario': [],
               u'actions after the feature': []}

    feature = ""
    scenario = None
    for num, field in enumerate(gherkin_list):
        if field.strip().startswith("|"):
            # The rest of the table has been already parsed into Scenario section
            continue

        if field.strip().startswith("@"):
            continue
        if field.strip().startswith("Feature"):
            # if field.find("Feature") > -1:
            feature = ":".join(field.split(":")[1:]).strip()
            scenarios[feature] = OrderedDict()
        elif field.lower().strip().startswith("actions"):
            action_name = field.lower().strip().rstrip(":")
            common_log("...Action:{}".format(action_name))
        elif field.strip().startswith("Scenario"):
            # Append after pre-defined actions in previous scenario
            if scenario:
                scenarios = add_actions(u'actions after each scenario', actions, scenarios, feature, scenario)
                scenarios = add_actions(u'actions after the feature', actions, scenarios, feature, scenario)
            action_name = None
            scenario = ":".join(field.split(":")[1:]).strip()

            scenarios[feature][scenario] = {"tl_id": None, "keywords": [], "executionType": 2, "steps": []}
            if gherkin_list[num - 1].startswith("@"):
                for tag in gherkin_list[num - 1].split("@")[1:]:
                    keyword = tag.strip()
                    if keyword.startswith("TL."):
                        scenarios[feature][scenario]["tl_id"] = keyword.split("TL.")[1].split()[0]
                        continue
                    if keyword in ("skip", "wip", "slow", "bug", ""):
                        continue
                    if keyword == "manual":
                        scenarios[feature][scenario]["executionType"] = 1
                    scenarios[feature][scenario]["keywords"].append(keyword)

            # Append before actions pre-defined
            scenarios = add_actions(u'actions before the feature', actions, scenarios, feature, scenario)
            scenarios = add_actions(u'actions before each scenario', actions, scenarios, feature, scenario)
        else:
            if field.strip().startswith(("Given", "When", "Then", "And", "But")):
                step = field.strip()
                if num + 1 < len(gherkin_list) and gherkin_list[num + 1].startswith("|"):
                    row_num = 1
                    step += '<p><table border="1" cellspacing="0" cellpadding="5">'
                    while True:
                        if row_num == 1:
                            step += re.sub('.\|.', '</th><th>', re.sub('\|$', '</th></tr>',
                                                                       re.sub('^\|*', '<tr><th>', gherkin_list[
                                                                           num + row_num].strip())))
                        else:
                            step += re.sub('.\|.', '</td><td>', re.sub('\|$', '</td></tr>',
                                                                       re.sub('^\|*', '<tr><td>', gherkin_list[
                                                                           num + row_num].strip())))
                        if num + row_num + 1 < len(gherkin_list) and gherkin_list[num + row_num + 1].startswith("|"):
                            row_num += 1
                        else:
                            step += '</table><p>'
                            break

                if action_name:
                    actions[action_name].append(step)
                else:
                    scenarios[feature][scenario]["steps"].append(step)
            else:
                scenarios[feature][scenario]["steps"].append(step)

    # Append after pre-defined actions in last scenario
    if scenario:
        scenarios = add_actions(u'actions after each scenario', actions, scenarios, feature, scenario)
        scenarios = add_actions(u'actions after the feature', actions, scenarios, feature, scenario)

    logging.debug("---Scenarios: {}".format(scenarios))
    logger_ordered_dict(scenarios)

    return scenarios


def add_testcases_to_testlink(project_name, author, scenarios, without_steps, update, with_tags):
    """
    Add testcases requesting testlink CGI
    :param project_name: Name of project in Testlink
    :param author: Username of loged user in Testlink
    :param scenarios: Data to insert in Testlink
    :return: None
    """
    result = ""
    action = ""
    ids = []
    for test_suite, test_cases in scenarios.items():
        for test_case, test_case_attributes in test_cases.items():
            if len(test_case) > 300:
                result = "ERROR, test case title length(%s) > 300 characters" % len(test_case)
                common_log(result)
            else:
                steps = []
                command = ""
                if not without_steps:
                    logging.debug("...with steps")
                    i = 0
                    for test_step in test_case_attributes["steps"]:
                        i += 1
                        steps.append({'step_number': i, 'actions': test_step,
                                      'execution_type': test_case_attributes['executionType']})

                # Fix characters
                fixed_project_name = _escape_url_characters(project_name)
                fixed_test_case = _escape_url_characters(test_case)
                fixed_steps = _escape_url_characters(steps)
                fixed_author = _escape_url_characters(author)
                fixed_execution_type = _escape_url_characters(test_case_attributes["executionType"])

                if with_tags:
                    fixed_keywords = _escape_url_characters(test_case_attributes["keywords"])

                if not test_case_attributes["tl_id"]:
                    logging.debug("...not test_case_attributes")

                    # Fix characters
                    fixed_test_suite = _escape_url_characters(test_suite)

                    command = TESTLINK_URL + GET_PATH_ADD % (fixed_project_name, fixed_test_suite, fixed_test_case,
                                                             fixed_author, fixed_steps, fixed_execution_type)

                    command = "%s&keywords=%s" % (command, fixed_keywords) if with_tags else command

                    action = "Adding"
                elif test_case_attributes["tl_id"] and update:
                    logging.debug("Update action is in surveillance mode")

                    # Fix characters
                    fixed_tl_id = _escape_url_characters(test_case_attributes["tl_id"])

                    command = TESTLINK_URL + GET_PATH_UPDATE % (fixed_project_name, fixed_tl_id, fixed_test_case,
                                                                fixed_author, fixed_steps, fixed_execution_type)
                    command = "%s&keywords=%s" % (command, fixed_keywords) if with_tags else command

                    action = "Updating tc_id: %s" % test_case_attributes["tl_id"]

                if not command:
                    continue

                response = requests.get(command, verify=False)

                logging.debug("Action={}".format(action))
                logging.debug(command)
                if action != "":
                    if response.status_code == 200:
                        try:
                            result = "OK"
                            external_testlink_id = response.text.split("Id:")[1].strip()
                            ids.append(external_testlink_id)
                        except IndexError as e:
                            result = "ERROR-TL-ID"
                            if action.startswith("Updating tc_id:"):
                                result = "{}".format(response.text)
                    else:
                        result = response.reason
                        logging.error("%d - %s", response.status_code, result)
                    out_msg = "%s tc: %s to ts: %s --> %s" % (action, test_case, test_suite, result)
                    common_log(out_msg)

            action = ""

    if not update and len(ids) == 0:
        common_log("ERROR: There are not IDs generated. Revise how to handle tl_ids")
    return ids


def add_feature_cli_definition(parser):
    """
    CLI definition for Add-Features script
    :param parser to define CLI arguments
    """

    parser.add_argument("-f", "--file", dest="filename",
                        help="(Mandatory) Feature file or features folder", metavar="FILE", required=True)
    parser.add_argument("-a", "--author", dest="author",
                        help="(Mandatory) TestCase author", required=True)
    parser.add_argument("-p", "--project", dest="project_name",
                        help="(Mandatory) Testlink project name", required=True)
    parser.add_argument("--without-steps", action="store_true", dest="without_steps",
                        help="Add steps to test cases")
    parser.add_argument("-u", "--update", action="store_true", dest="update",
                        help="Update Testlink test cases")
    parser.add_argument("-t", "--with-tags", action="store_true", dest="with_tags",
                        help="Add a keyword in Testlink for each tag in the Scenario (if exists in Testlink)")
    parser.add_argument("-i", "--with_ids", action="store_true", dest="with_ids",
                        help="Add test IDs to feature."
                             "By default the output file name will be [FILE]-with_ids.feature."
                             "You can use specific output file name with -o option")
    parser.add_argument("-o", "--output_file", action="store", dest="output_file",
                        help="Feature file with ids")
    parser.add_argument("-l", "--language", action="store", dest="language",
                        help="Translate [LANG:...] labels in steps using given language")


def add_features_main(args):
    logging.basicConfig(filename=os.path.join('add_features.log'),
                        format='%(asctime)s %(levelname)s %(message)s',
                        level=logging.DEBUG)

    logging.debug("__________________________Start Application_____________________________")

    if os.path.isfile(args.filename):
        feature_files = [args.filename]
    elif os.path.isdir(args.filename):
        # Get files list from folder
        common_log("Folder with features: %s\n" % args.filename)
        feature_files = []
        for root, dirs, files in os.walk(args.filename):
            feature_files += [os.path.join(root, file) for file in files if file.endswith(".feature")]

    # Add features to testlink
    append_file = False
    for feature_file in feature_files:
        common_log("File to parser: %s\n" % feature_file)

        scenarios = parse_feature_execution(feature_file, args.language)
        logging.debug("Scenario parsed: {}\n".format(scenarios.items()))

        test_ids = add_testcases_to_testlink(args.project_name, args.author, scenarios, args.without_steps,
                                             args.update, args.with_tags)
        common_log("\nTest IDS: {}\n".format(test_ids))

        if args.with_ids:
            output_file = args.output_file if args.output_file else feature_file.replace(EXT_ORG, EXT_END)
            common_log("\nTrying to generate {} with ids\n".format(output_file))

            fp = FeatureParser(feature_file, output_file)
            common_log("....FeatureParser")
            ids_per_scenario = fp.get_number_of_tests_per_scenario()
            common_log("....ids_per_scenario")
            final_list = fp.match_scenarios_to_test_ids(test_ids, ids_per_scenario)

            map(lambda s, _id: s.add_testlink_id(_id), fp.feature.scenarios, final_list)
            fp.write_feature(append_file)
            append_file = True if args.output_file else False
            common_log("\nGenerated output file with ids\n")


def _escape_url_characters(obj):
    """
    Replace some special characters which are accepted as valid URL characters, but is needed to be url-encoded
    :param obj: Object to search and replace the characters. If is not a string object first cast to string.
    :return: String with characters replaced
    """
    new_string = obj if isinstance(obj, basestring) else str(obj)
    for key, value in URL_ESCAPE_CHARACTERS.iteritems():
        new_string = new_string.replace(key, value)

    return new_string
