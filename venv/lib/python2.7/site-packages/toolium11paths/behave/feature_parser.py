# -*- coding: utf-8 -*-

# Copyright (c) Telef√≥nica Digital.
# CDO QA Team <qacdo@telefonica.com>

import json
import logging

from behave import parser
from behave.model import ScenarioOutline
from behave.model_describe import ModelDescriptor

ERROR_TAG_EXIST = u"\n...ERROR: Check if exist TL tags in some Test Case or are previously defined in TestLink...\n"
ERROR_DUPLICATED_SCENARIO_DESC = u"\n...ERROR: Is there any scenario description repeated???...\n"
ERROR_TESTLINKID_COLUMN_SCENARIO = u"\n...ERROR: Are there any column named testlink_id in examples table???...\n"

logger = logging.getLogger(__name__)


class FeatureParser(object):
    N_SPACES = 2

    def __init__(self, input_feature, output_feature=None):
        self.input_feature = input_feature
        self.output_feature = output_feature
        self.feature = MyFeature(parser.parse_file(self.input_feature))

    @staticmethod
    def write_spaces(indent_level=1, increment=0):
        return " " * (FeatureParser.N_SPACES * indent_level + increment)

    def feature2json(self):
        return json.dumps(self.feature.load_feature(), indent=2)

    def write_feature(self, append_file=False):
        if self.output_feature is None:
            self.output_feature = self.input_feature.split(".feature")[0] + "_with_ids" + ".feature"

        file_mode = "a" if append_file else "w"
        with open(self.output_feature, file_mode) as output_feature:
            output_feature.write("# -*- coding: utf-8 -*-\n\n")
            for line in self.feature.dump_feature():
                output_feature.write(line.encode("utf8"))

    def get_number_of_tests_per_scenario(self):
        return [sum([len(e.table.table.rows) for e in s.examples]) if isinstance(s, MyScenarioOutline) else 1 for s in
                self.feature.scenarios]

    def match_scenarios_to_test_ids(self, testlink_ids, number_of_tests_per_scenario):
        def take_elemen(l, pos, number):
            return l[pos:pos + number]

        pos, r = 0, []
        for number in number_of_tests_per_scenario:
            r.append(take_elemen(testlink_ids, pos, number))
            pos += number
        return r


class MyFeature(object):
    def __init__(self, feature):
        self.feature = feature
        self.background = MyBackground(self.feature.background) if self.feature.background is not None else None
        self.scenarios = [MyScenarioOutline(scenario) if isinstance(scenario, ScenarioOutline) else MyScenario(scenario)
                          for scenario in self.feature.scenarios]

    def load_feature(self):
        _feature = {"name": self.feature.name, "description": self.feature.description, "keyword": self.feature.keyword,
                    "tags": self.feature.tags, "scenarios": [scenario.load_scenario() for scenario in self.scenarios]}
        if self.background is not None:
            _feature["background"] = self.background.load_background()

    def dump_feature(self):
        _str = [u"{}: {}\n".format(self.feature.keyword, self.feature.name),
                u"{}{}\n".format(FeatureParser.write_spaces(),
                                 u"\n{}".format(FeatureParser.write_spaces()).join(self.feature.description))]

        if len(self.feature.description) > 0:
            _str.append(u"\n")

        if len(self.feature.tags) > 0:
            _str.insert(0, u"\n".join([u"{}@{}".format(FeatureParser.write_spaces(MyScenario.INDENT_LEVEL), tag)
                                       for tag in self.feature.tags]))
            _str.insert(1, u"\n")

        if self.background is not None:
            [_str.append(l) for l in self.background.dump_background()]
            _str.append(u"\n")

        [_str.append(l) for s in self.scenarios for l in s.dump_scenario()]
        _str.pop(-1)
        return _str


class MyBackground(object):
    INDENT_LEVEL = 1

    def __init__(self, background):
        self.background = background
        self.steps = [MyStep(step) for step in self.background.steps]

    def load_background(self):
        return {"name": self.background.name, "keyword": self.background.keyword,
                "steps": [step.load_step() for step in self.steps]}

    def dump_background(self):
        _str = [u"{}{}: {}\n".format(FeatureParser.write_spaces(MyBackground.INDENT_LEVEL),
                                     self.background.keyword, self.background.name)]
        [_str.append(l) for s in self.steps for l in s.dump_step()]
        return _str


class MyScenario(object):
    INDENT_LEVEL = 1

    def __init__(self, scenario):
        self.scenario = scenario
        self.steps = [MyStep(step) for step in self.scenario.steps]

    def load_scenario(self):
        _scenario = {"name": self.scenario.name, "keyword": self.scenario.keyword, "tags": self.scenario.tags,
                     "description": self.scenario.description,
                     "steps": [step.load_step() for step in self.steps]}
        return _scenario

    def dump_scenario(self):
        _str = [u"{}{}: {}\n".format(FeatureParser.write_spaces(MyScenario.INDENT_LEVEL), self.scenario.keyword,
                                     self.scenario.name)]
        if len(self.scenario.tags) > 0:
            _str.insert(0, "\n".join([u"{}@{}".format(FeatureParser.write_spaces(MyScenario.INDENT_LEVEL), tag)
                                      for tag in self.scenario.tags]))
            _str.insert(1, u"\n")

        [_str.append(l) for s in self.steps for l in s.dump_step()]
        _str.append(u"\n")
        return _str

    def add_tags(self, tags):
        self.scenario.tags.extend(tags)

    def add_testlink_id(self, test_id):
        logger.debug("MyScenario.add_testlink_id: {}".format(test_id))
        try:
            self.add_tags(["TL.{}".format(test_id[0])])
        except IndexError as e:
            logging.error(ERROR_TAG_EXIST)
            print(ERROR_TAG_EXIST)
            raise e


class MyScenarioOutline(MyScenario):
    def __init__(self, scenario):
        super(MyScenarioOutline, self).__init__(scenario)
        self.examples = [MyScenarioExample(example) for example in self.scenario.examples]

    def load_scenario(self):
        _scenario = super(MyScenarioOutline, self).load_scenario()
        _scenario["examples"] = [example.load_example() for example in self.examples]
        logger.debug("...MyScenarioOutline. Loaded Scenario")
        logger.debug(_scenario)
        return _scenario

    def dump_scenario(self):
        _str = super(MyScenarioOutline, self).dump_scenario()
        [_str.append(l) for e in self.examples for l in e.dump_example()]
        return _str

    def add_testlink_id(self, test_id):
        logger.debug("MyScenarioOutline.add_testlink_id: {}".format(test_id))
        pos = 0
        for example in self.examples:
            pos += example.add_testlink_id(test_id[pos:])

        self.add_tags(["TL.<testlink_id>"])


class MyScenarioExample(object):
    INDENT_LEVEL = 2

    def __init__(self, example):
        self.example = example
        self.table = MyTable(self.example.table)

    def load_example(self):
        return {"name": self.example.name, "keyword": self.example.keyword,
                "table": self.table.load_table()}

    def dump_example(self):
        _str = [u"{}{}: {}\n".format(FeatureParser.write_spaces(MyScenarioExample.INDENT_LEVEL),
                                     self.example.keyword, self.example.name)]
        [_str.append(l) for l in self.table.dump_table()]
        _str.append(u"\n")
        return _str

    def add_testlink_id(self, test_id):
        logger.debug("MyScenarioExample.add_testlink_id: {}".format(test_id))
        if len(test_id) < len(self.table.table.rows):
            try:
                self.table.table.add_column("testlink_id", values=test_id, default_value=test_id[-1])
            except IndexError as e:
                logger.error(ERROR_DUPLICATED_SCENARIO_DESC)
                print(ERROR_DUPLICATED_SCENARIO_DESC)
                raise e
        else:
            try:
                self.table.table.add_column("testlink_id", values=test_id)
            except AssertionError as ie:
                logger.error(ERROR_TESTLINKID_COLUMN_SCENARIO)
                print(ERROR_TESTLINKID_COLUMN_SCENARIO)
                raise ie

        return len(self.table.table.rows)


class MyStep(object):
    INDENT_LEVEL = 2

    def __init__(self, step):
        self.step = step
        self.table = MyTable(step.table)
        self.text = step.text

    def load_step(self):
        _step = {"name": self.step.name, "keyword": self.step.keyword}
        if self.table.table is not None:
            _step["table"] = self.table.load_table()
        if self.text is not None:
            _step["text"] = self.text
        return _step

    @staticmethod
    def _get_index_level_increment_type(step_keyword):
        if step_keyword == "Given":
            return 0
        elif step_keyword in ["When", "Then"]:
            return 1
        elif step_keyword in ["And", "But"]:
            return 2

    def dump_step(self):
        _str = [u"{}{} {}".format(FeatureParser.write_spaces(MyStep.INDENT_LEVEL,
                                                             MyStep._get_index_level_increment_type(self.step.keyword)),
                                  self.step.keyword, self.step.name),
                u"\n"]
        if self.table.table is not None:
            [_str.append(l) for l in self.table.dump_table()]
        if self.text is not None:
            _str.append(ModelDescriptor.describe_docstring(self.text,
                                                           FeatureParser.write_spaces(MyTable.INDENT_LEVEL, 6)))
        return _str


class MyTable(object):
    INDENT_LEVEL = 2

    def __init__(self, table):
        self.table = table

    def load_table(self):
        return {"headings": self.table.headings, "rows": [r.cells for r in self.table.rows]}

    def dump_table(self):
        return [ModelDescriptor.describe_table(self.table,
                                               indentation=FeatureParser.write_spaces(MyTable.INDENT_LEVEL, 6))]
