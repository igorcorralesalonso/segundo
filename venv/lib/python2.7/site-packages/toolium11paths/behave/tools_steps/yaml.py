# -*- coding: utf-8 -*-

"""
Copyright (c) Telefonica Digital | Eleven Paths.
ElevenPaths QATeam
"""

import os

# noinspection PyUnresolvedReferences
from behave import step as behave_step
from toolium11paths.behave import step
from toolium11paths.behave.tools_steps.blank_vulnerability_html_parser import BlankVulnerabilityHtmlParser
from toolium11paths.behave.tools_steps.image_elements_html_parser import ImageElementsHtmlParser
from toolium11paths.behave.tools_steps.page_elements_html_parser import PageElementsHtmlParser

__all__ = ['tool_elements_id_wrap', 'checking_img_src',
           'tool_elements_id_search', 'tool_elements_xpath_search',
           'checking_target_blank']


@step(u'TOOL: I generate YAML "{viewable}" elements by ID on the "{currentpage}" page')
def tool_elements_id_wrap(context, viewable, currentpage):
    """
    :param context: behave context
    :param viewable: selecting wraping mode on visible elems only or all ID founds on wrapping (if param = "all")
    :param currentpage: string used to file creating .yaml
    :outputs: 2 files
            - yaml page object
            - elem list found to check (behave table format)
    """
    page_content = context.driver.page_source
    parser = PageElementsHtmlParser(context, viewable, None, currentpage)
    parser.feed(page_content)
    # Writing elems table on aux file
    dir = "_output/tools"
    if not os.path.isdir(dir):
        os.makedirs(dir)
    content = open(os.path.join(dir, currentpage.lower() + ".elem"), "w")

    # Creation of output .elem file to insert in table
    for elem in parser.foundids:
        blanks = 30 - len(elem)
        space = ""
        for i in range(1, blanks):
            space += " "
        content.writelines("                     | " + elem + space + " |\n")


@step(u'TOOL: I generate YAML elements by ID matching "{query_string}" on the "{currentpage}" page')
def tool_elements_id_search(context, query_string, currentpage):
    """
    :param context: behave context
    :param query_string: partial string to match with id elems
    :param currentpage: string used to file creating .yaml
    :outputs: 2 files
            - yaml page object
            - elem list found to check (behave table format)
    """
    page_content = context.driver.page_source
    parser = PageElementsHtmlParser(context, None, query_string, currentpage)
    parser.feed(page_content)
    # Writing elems table on aux file
    dir = "_output/tools"
    if not os.path.isdir(dir):
        os.makedirs(dir)
    content = open(os.path.join(dir, currentpage.lower() + ".elem"), "w")


@step(u'TOOL: I generate YAML elements by XPATH "{locator}" matching "{query_string}" on the "{currentpage}" page')
def tool_elements_xpath_search(context, locator, query_string, currentpage):
    """
    :param context: behave context
    :param locator: xpath locator
    :param query_string: partial string to match with xpath elems
                # "[]" or querystring.lower()=="[EMPTY]" -> to search for ANY elem
    :param currentpage: string used to file creationg .yaml
    :outputs: 1 file: yaml page object
    """
    LOCATORLIST = ("id", "class", "href", "name", "css", "alt", "srcset")
    if query_string.lower() == "[]" or query_string.lower() == "[EMPTY]":
        query_string = ""

    if locator.lower() in LOCATORLIST:
        page_content = context.driver.page_source
        parser = PageElementsHtmlParser(context, None, query_string, currentpage, locator=locator)
        parser.feed(page_content)
    else:
        print("\n\n\a -------------- TOOL ERROR --------------\n -> Locator type not allowed. \n\n\n\n\n")
        context.logger.warn("WARNING : [TOOL] Tool step using Locator type not allowed: " + locator)
        assert False


@step(u'I check img sources on the currentpage page')
def checking_img_src(context):
    """
    Make a request to all "img src=URL", if any request status code != 200 then step fails
    :param context: behave context
    """
    page_content = context.driver.page_source
    parser = ImageElementsHtmlParser(context)
    parser.feed(page_content)
    # Writing elems table on aux file
    # content = open(os.path.join("_output/tools/img_src.elem"),"w")


@step(u'I check target blank vulnerability')
def checking_target_blank(context):
    """
    Checks all links as target=_blank if not fixed as vulneratibility using rel="noopener noreferer"
    Example to test: pagecontent = u'<HMTL><HEAD><TITLE>webpage1</TITLE></HEAD><BODY rel="noopener noreferrer" BGCOLOR="FFFFFf" LINK="006666" ALINK="8B4513" VLINK="006666" target="_blank">'
    :param context: behave context
    """
    page_content = context.driver.page_source
    parser = BlankVulnerabilityHtmlParser(context)
    parser.feed(page_content)
