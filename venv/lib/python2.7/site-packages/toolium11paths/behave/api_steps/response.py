# -*- coding: utf-8 -*-

"""
Copyright (c) Telefonica Digital.
ElevenPaths QA Team <qateam@11paths.com>
"""

"""
Verify HTTP responses easily using Gherkin language.
"""

import json
import os
import urllib
# noinspection PyUnresolvedReferences
from behave import step as behave_step
from toolium11paths.behave import step
from toolium11paths.utils.configuration import map_json_param
from jsonschema import Draft4Validator
from jsonschema import RefResolver
from jsonschema.exceptions import ValidationError
from jsonschema.validators import meta_schemas


__all__ = ('http_status_code_should_be', 'http_status_code_not_should_be', 'http_status_code_should_be_success',
           'http_status_code_should_be_redirection', 'http_status_code_should_be_client_error',
           'http_status_code_should_be_server_error', 'http_reason_phrase_should_be',
           'http_reason_phrase_should_not_be', 'http_response_body_should_be_this_json', 'check_json_field_value',
           'check_json_field_text', 'elements_from_table_contain_text', 'validate_body_against_schema',
           'http_response_body_should_contain_this_string')


@step('The HTTP status code should be "{code:d}"')
def http_status_code_should_be(context, code):
    assert context.api_response.status == code


@step('The HTTP status code should not be "{code:d}"')
def http_status_code_not_should_be(context, code):
    assert context.api_response.status != code


@step(u'The HTTP status code should be SUCCESS (2XX)')
def http_status_code_should_be_success(context):
    assert str(context.api_response.status)[0] == '2', \
        u"Expected: 2XX; Message: {}".format(context.api_response.status)


@step(u'The HTTP status code should be REDIRECTION (3XX)')
def http_status_code_should_be_redirection(context):
    assert str(context.api_response.status)[0] == '3', \
        u"Expected: 3XX; Message: {}".format(context.api_response.status)


@step(u'The HTTP status code should be CLIENT ERROR (4XX)')
def http_status_code_should_be_client_error(context):
    assert str(context.api_response.status)[0] == '4', \
        u"Expected: 4XX; Message: {}".format(context.api_response.status)


@step(u'The HTTP status code should be SERVER ERROR (5XX)')
def http_status_code_should_be_server_error(context):
    assert str(context.api_response.status)[0] == '5', \
        u"Expected: 5XX; Message: {}".format(context.api_response.status)


@step('The HTTP reason phrase should be "{reason}"')
def http_reason_phrase_should_be(context, reason):
    assert context.api_response.reason == reason


@step('The HTTP reason phrase should contain "{reason}"')
def http_reason_phrase_should_not_be(context, reason):
    assert context.api_response.reason != reason


@step('The response header "{header_name}" should be "{header_value}"')
def http_response_header_should_be(context, header_name, header_value):
    assert header_name in context.api_response.headers, "Header not present: %s" % header_name
    received_value = context.api_response.headers[header_name]
    assert header_value == received_value


@step('The response header "{header_name}" should contain "{header_value}"')
def http_response_header_should_contain(context, header_name, header_value):
    assert header_name in context.api_response.headers, "Header not present: %s" % header_name
    received_value = context.api_response.headers[header_name]
    assert header_value in received_value, \
        "Header %s does not contain expected value %s; Received: %s" % (header_name, header_value, received_value)


@step('The response body should contain this parameters')
def http_response_body_should_contain_this_parameters(context):
    pass


@step('The response body should be this "{response_file}"')
def http_response_body_should_be_this_file(context, response_file):
    pass


@step('The response body should be this JSON')
def http_response_body_should_be_this_json(context):
    """
    Parameters:

        .. code-block:: json

            {
                "param1": "value1",
                "param2": "value2",
                "param3": {
                    "param31": "value31"
                }
            }
    """
    body_params = json.loads(context.text)
    assert body_params == context.api_response.data


@step('The response body should contain this string')
def http_response_body_should_contain_this_string(context):
    """
    Parameters:
        {partial string to compare to json response}
    """
    body_params = context.text.strip()
    response = context.api_response.raw
    assert body_params in response, \
        "Expected: {}; Message: {}".format(body_params, context.api_response.data)


@step('The response body should be this XML')
def http_response_body_should_be_this_xml(context):
    pass


@step(u'The json field "{field_structure}" has the value "{value}"')
def check_json_field_value(context, field_structure, value):
    """
    Step. Assert: Checks in the api response, if specified field structure has the given value.
    Example: Some example of field structure should be (for the example json below):

        - "field1.field2.field201" for "value201"
        - "field2.2.field226 for "value226"
        - "field2.0" for
                {
                "field201":"value201",
                "field202":"value202"
                }
        - "field2" for
            "[
            {
                "field201":"value201",
                "field202":"value202"
            },
            {
                "field213":"value213",
                "field224":"value214"
            },
            {
                "field225":"value225",
                "field226":"value226"
            }
             ]"
    json example:
    {   "field1": "value1",
        "field2": [
            {
                "field201":"value201",
                "field202":"value202"
            },
            {
                "field213":"value213",
                "field224":"value214"
            },
            {
                "field225":"value225",
                "field226":"value226"
            }
        ],
        "field3" : {
            "field31" : {
                "field311": "value311",
                "field312": "value312"
                },
            "field32" : "value32"
        },
        "field4" : "value",
        "field5" : "value"
    }
    :param field_structure: json field structure.
    :param value: value in the element of the json.
    """

    value_to_check = map_json_param(field_structure, context.api_response.json)
    assert str(value_to_check) == str(value), "Expected: {}; Response: {}".format(value, value_to_check)


@step(u'The json field "{field_structure}" has the type "{typeof}"')
def check_json_field_type(context, field_structure, typeof):
    """
    Step. Assert: Checks in the api response, if specified field structure has the given type.
    Example: Some example of field structure should be (for the example json below):

        - "field1.field2.field201" for "value201"
        - "field2.2.field226 for "value226"
        - "field2.0" for
                {
                "field201":"value201",
                "field202":"value202"
                }
        - "field2" for
            "[
            {
                "field201":"value201",
                "field202":"value202"
            },
            {
                "field213":"value213",
                "field224":"value214"
            },
            {
                "field225":"value225",
                "field226":"value226"
            }
             ]"
    json example:
    {   "field1": "value1",
        "field2": [
            {
                "field201":"value201",
                "field202":"value202"
            },
            {
                "field213":"value213",
                "field224":"value214"
            },
            {
                "field225":"value225",
                "field226":"value226"
            }
        ],
        "field3" : {
            "field31" : {
                "field311": "value311",
                "field312": 312
                },
            "field32" : "value32"
        },
        "field4" : "value",
        "field5" : "value"
    }
    :param field_structure: json field structure.
    :param typeof: type in the element of the json.
    """

    value_to_check = map_json_param(field_structure, context.api_response.json)
    assert type(value_to_check) is eval(typeof), "Expected: {}; Response: {}".format(eval(typeof), type(value_to_check))


@step(u'The json field "{field_structure}" has the structure')
@step(u'The json field "{field_structure}" has the structure "{value}"')
def check_json_field_text(context, field_structure, value=None):
    """
    Step. Assert: Checks in the api response, if specified field structure has the json structure specified as behave text. Example:
    [...]
    And The json field "field2.0" has the structure:
          \"\"\"
          {
                "field201":"value201",
                "field202":"value202"
            }
          \"\"\"
    [...]
    Some example of field structure should be (for the example json below):
        - "field1.field2.field201" for "value201"
        - "field2.2.field226 for "value226"
        - "field2.0" for
                {
                "field201":"value201",
                "field202":"value202"
                }
        - "field2" for
            "[
            {
                "field201":"value201",
                "field202":"value202"
            },
            {
                "field213":"value213",
                "field224":"value214"
            },
            {
                "field225":"value225",
                "field226":"value226"
            }
             ]"
    json example:
    {   "field1": "value1",
        "field2": [
            {
                "field201":"value201",
                "field202":"value202"
            },
            {
                "field213":"value213",
                "field224":"value214"
            },
            {
                "field225":"value225",
                "field226":"value226"
            }
        ],
        "field3" : {
            "field31" : {
                "field311": "value311",
                "field312": "value312"
                },
            "field32" : "value32"
        },
        "field4" : "value",
        "field5" : "value"
    }

    :param context: Behave Context.
    :text : structure to check
    :param field_structure : json field structure.
    :param value: structure value in the element of the json. If is None, use the context text
    """
    valueToCheck = map_json_param(field_structure, context.api_response.json)
    assert json.loads(value or context.text) == valueToCheck, u"Expected: {}; Response: {}".format(unicode(context.text),
                                                                                          unicode(str(valueToCheck)))


@step(u'The json field in the table has the value')
def elements_from_table_contain_text(context):
    """
    Step. Assert: Checks if the given values are contained in elements on the table.
    [...]
    And The json field in the table has the value
    | element                 | text_value |
    | field2.1.field213       | value213  |
    | field3.field31.field312 | value312 |
    [...]
    Some example of field structure should be (for the example json below):
        - "field1.field2.field201" for "value201"
        - "field2.2.field226 for "value226"
        - "field2.0" for
                {
                "field201":"value201",
                "field202":"value202"
                }
        - "field2" for
            "[
            {
                "field201":"value201",
                "field202":"value202"
            },
            {
                "field213":"value213",
                "field224":"value214"
            },
            {
                "field225":"value225",
                "field226":"value226"
            }
             ]"

    json example:
    {   "field1": "value1",
        "field2": [
            {
                "field201":"value201",
                "field202":"value202"
            },
            {
                "field213":"value213",
                "field224":"value214"
            },
            {
                "field225":"value225",
                "field226":"value226"
            }
        ],
        "field3" : {
            "field31" : {
                "field311": "value311",
                "field312": "value312"
                },
            "field32" : "value32"
        },
        "field4" : "value",
        "field5" : "value"
    }

    :param context: Behave Context.
    :Table Headers
    :Header element: element.
    :Header text_value: text_value
    """
    for row in context.table:
        context.execute_steps(u"""
        Then The json field "{field_structure}" has the value "{value}"
        """.format(field_structure=row["element"], value=row["text_value"]))


@step(u'The json field in the table is an instance of')
@step(u'The json field in the table has the type')
def elements_from_table_are_equals_to_types_of_primitives(context):
    """
    Step. Assert: Checks if the elements in the given table are instance of the types of primitives.
    [...]
    And The json field in the table is an instance of
    | element                 | type |
    | field2.1.field213       | str  |
    | field3.field31.field312 | int  |
    [...]
    Some example of field structure should be (for the example json below):
        - "field1.field2.field201" for "value201"
        - "field2.2.field226 for "value226"
        - "field2.0" for
                {
                "field201":"value201",
                "field202":"value202"
                }
        - "field2" for
            "[
            {
                "field201":"value201",
                "field202":"value202"
            },
            {
                "field213":"value213",
                "field224":"value214"
            },
            {
                "field225":"value225",
                "field226":"value226"
            }
             ]"

    json example:
    {   "field1": "value1",
        "field2": [
            {
                "field201":"value201",
                "field202":"value202"
            },
            {
                "field213":"value213",
                "field224":"value214"
            },
            {
                "field225":"value225",
                "field226":"value226"
            }
        ],
        "field3" : {
            "field31" : {
                "field311": "value311",
                "field312": 312
                },
            "field32" : "value32"
        },
        "field4" : "value",
        "field5" : "value"
    }

    :param context: Behave Context.
    :Table Headers
    :Header element: element.
    :Header text_value: text_value
    """
    for row in context.table:
        context.execute_steps(u"""
        Then The json field "{field_structure}" has the type "{typeof}"
        """.format(field_structure=row["element"], typeof=row["type"]))


@step(u'The response body is validated against the schema {schema}')
def validate_body_against_schema(context, schema):
    """
    :param schema:  The filename containing a valid jsonschema to validate the response body.
                    The schema file must be placed in resources/json_schemas.
                    The extension of schema file must be ".json"
    """
    path = urllib.pathname2url(os.path.splitdrive(os.path.abspath(os.path.join('resources', 'json_schemas')))[1])

    with open(os.path.join(path, schema + '.json')) as data_file:
        content = context.map_param(data_file.read(), context)
        json_schema = json.loads(content)

    validator = meta_schemas.get(json_schema.get(u"$schema", u""), Draft4Validator)

    resolver = RefResolver('file://' + path + '/', json_schema)
    try:
        validator(json_schema, resolver=resolver).validate(context.api_response.data)
    except ValidationError as err:
        raise AssertionError(err.message)
