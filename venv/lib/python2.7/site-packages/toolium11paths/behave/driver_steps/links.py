# -*- coding: utf-8 -*-

"""
Copyright (c) Telefonica Digital.
ElevenPaths QA Team <qateam@11paths.com>
"""

import time

from selenium.webdriver import ActionChains

# noinspection PyUnresolvedReferences
from behave import step as behave_step
from toolium11paths.behave import step

__all__ = ('press_button', 'click_button', 'press_element_in_list', 'click_button_and_go_to',
           'press_element_in_list_by_text')


@step(u'I press "{name}" button')
def press_button(context, name):
    """
    Press button but no new page is loaded. e.i: To check that an error arises.
    """
    element = context.get_element_from_current_page(name)
    element.click()


@step(u'I click on "{name}" element')
@step(u'I click on "{name}" button')
def click_button(context, name):
    """
    Press button and:
      - the SAME page is reloaded (reset the current page elements and page object)
      - or a NEW page is loaded but, in this last case, the 'context.page' is not updated.
      This way, it needs to be updated by calling the step: 'the "{resource}" page is loaded'
    """

    element = context.get_element_from_current_page(name)
    element.click()


@step(u'I press the element in position {position:d} in the elements list "{elements_list}"')
def press_element_in_list(context, position, elements_list):
    """
    Press button inside a list of buttons with the same ID.
    position: Position of button inside the list, starting by 1.
    elements_list: Set of elements defined in page object definition.
    """
    element = context.get_element_from_current_page(elements_list)
    element.page_elements[position - 1].click()


@step(u'I press the element with text "{expected_text}" in the elements list "{elements_list}"')
def press_element_in_list_by_text(context, expected_text, elements_list):
    """
    Press button inside a list of buttons with the same ID matching the given text.

    :param context: toolium context.
    :param expected_text: Text to match with the text of the list elements.
    :param elements_list: Set of elements defined in page object definition.
    """
    elements_list = context.get_element_from_current_page(elements_list)
    elements = filter(lambda element: element.text == expected_text, elements_list.page_elements)

    assert len(elements) == 1, u'Found {} elements with this text "{}". 1 expected'.format(len(elements), expected_text)

    next(iter(elements)).click()


@step(u'I click on "{element}" with offset "{x:d},{y:d}"')
def click_element_with_offset(context, element, x, y):
    """
    Click on element with a specific offset

    :param context: Toolium context
    :param element: Target element
    :param x:       X coords
    :param y:       Y coords
    """
    web_element = context.get_element_from_current_page(element).web_element

    actions = ActionChains(context.driver)
    actions.move_to_element_with_offset(web_element, x, y).click().perform()


@step(u'I click on "{name}" element to go to "{resource}" page')
@step(u'I click on "{name}" button to go to "{resource}" page')
@step(u'I click "{name}" button to go to "{resource}" page')
def click_button_and_go_to(context, name, resource):
    """
    Press button, a new page is loaded and 'context.page' is updated with the given resource.
     e.i: Moving to another page.
    """
    element = context.get_element_from_current_page(name)
    element.click()

    context.page = context.get_page_object(resource)
    context.page.wait_until_loaded()


@step(u'I click on "{element_name}" button and switch to the new window')
def click_and_switch(context, element_name):
    """
    Click on button an switch to the new window/tab.
     A NEW page is loaded but, in this last case, the 'context.page' is not updated.
     This way, it needs to be updated by calling the step: 'the "{resource}"
     page is loaded' after switch to window.
     This step saves in 'context.default_window_handle' the current window handle (before switching)
    """

    context.logger.debug("Window handles before click on '%s': '%s'", element_name, context.driver.window_handles)

    # Save default window handle: 0
    context.default_window_handle = context.driver.window_handles[0]

    element = context.get_element_from_current_page(element_name)
    element.click()

    # Wait 1 second to be sure that new window is open
    time.sleep(1)

    context.logger.debug("Window handles after click on '%s': '%s'", element_name, context.driver.window_handles)

    context.logger.info("Switching driver to last opened window")
    context.driver.switch_to.window(context.driver.window_handles[-1])
    context.logger.debug("Driver switched: '%s'", context.driver)

    context.page.reset_object()


@step(u'I switch back to the default window')
def switch_to_default_window(context):
    """
    Switch driver back to the default window ('context.default_window_handle'),
     after this step execution
        'I click on "{element_name}" button and switch to the new window'
     The 'context.page' is not updated. If the page in the default window has changed,
      it needs to be updated by calling the step:
        'the "{resource}" page is loaded' after switch to window.
    """

    try:
        context.logger.info("Switching driver back to the default window")
        context.driver.switch_to.window(context.default_window_handle)
        context.logger.debug("Driver switched: '%s'", context.driver)
    except AttributeError:  # context.default_window_handle
        context.logger.error("Driver has not been switched previously to a new window")
        raise

    context.page.reset_object()
    del context.default_window_handle  # remove default_window_handle from context


@step(u'I switch back to the default window to go to "{resource}" page')
def switch_to_default_window_and_go_to(context, resource):
    """
    Switch driver back to the default window ('context.default_window_handle'),
     after this step execution
        'I click on "{element_name}" button and switch to the new window'
     The given page (resource) is loaded and 'context.page' is updated
      with the given resource.
    """

    context.execute_steps(u"""
        And I switch back to the default window
    """)

    context.page = context.get_page_object(resource)
    context.page.wait_until_loaded()
