# -*- coding: utf-8 -*-

"""
Copyright (c) Telefonica Digital.
ElevenPaths QA Team <qateam@11paths.com>
"""

import re

# noinspection PyUnresolvedReferences
from behave import step as behave_step
from bs4 import Tag
from selenium.webdriver.common.by import By

from toolium11paths.behave import step
from toolium11paths.utils.download_files import compare_downloaded_file

__all__ = ('element_contains_text', 'elements_from_table_contain_text', 'element_equal_text', 'check_value_filled',
           'elements_from_table_equal_text', 'elements_from_table_values_filled', 'element_of_selector_is_equal_to',
           'element_matches_regexp', 'alert_equal_text', 'column_cell_text_is', 'column_cell_text_is_not',
           'check_attribute_value_is', 'check_attribute_value_is_not', 'amount_of_tags_in_element_is',
           'amount_of_tags_in_element_is_not', 'amount_of_tags_in_element_is_greater',
           'amount_of_tags_in_element_is_less', '_format_text')


@step(u'the text of the element "{element}" is equal to "{expected_message}"')
@step(u'the text of the element "{element}" is equal to "{expected_message}" with params')
def element_equal_text(context, element, expected_message):
    """
    Step. Assert: Checks if the given message is equal to the text of the WebElement.

    :param context: Behave Context.
    :param element: WebElement name.
    :param expected_message: Text message to check.
    """
    expected_message = _format_text(context, expected_message)
    current_text = _get_element_text(context, element)

    assert current_text == expected_message, 'Element "{element}" text is not "{expected}". Current value: {current}'.\
        format(element=element, expected=expected_message, current=current_text)


@step(u'the text of the element "{element}" is not equal to "{invalid_message}"')
@step(u'the text of the element "{element}" is not equal to "{invalid_message}" with params')
def element_not_equal_text(context, element, invalid_message):
    """
    Step. Assert: Checks if the given message is not equal to the text of the WebElement.

    :param context: Behave Context.
    :param element: WebElement name.
    :param invalid_message: Text message to check.
    """
    invalid_message = _format_text(context, invalid_message)
    current_text = _get_element_text(context, element)

    assert not current_text == invalid_message, 'Element "{element}" text is "{invalid_message}".'. \
        format(element=element, invalid_message=invalid_message)


@step(u'the text of the element "{element}" contains "{expected_message}"')
@step(u'the text of the element "{element}" contains "{expected_message}" with params')
def element_contains_text(context, element, expected_message):
    """
    Step. Assert: Checks if the given message is contained in the text of the WebElement.

    :param context: Behave Context.
    :param element: WebElement name.
    :param expected_message: Text message to check.
    """
    expected_message = _format_text(context, expected_message)
    current_text = _get_element_text(context, element)

    assert expected_message in current_text, \
        'Element "{element}" text not contains "{expected}". Current value: {current}'.format(element=element,
                                                                                              expected=expected_message,
                                                                                              current=current_text)


@step(u'the text of the element "{element}" does not contain "{invalid_text}"')
@step(u'the text of the element "{element}" does not contain "{invalid_text}" with params')
def element_not_contains_text(context, element, invalid_text):
    """
    Step. Assert: Checks if the given message is not contained in the text of the WebElement.

    :param context: Behave Context.
    :param element: WebElement name.
    :param invalid_text: Text message to check.
    """
    invalid_text = _format_text(context, invalid_text)
    current_text = _get_element_text(context, element)

    assert invalid_text not in current_text, \
        'Element "{element}" text contains "{invalid_text}". Current value: {current}'.format(element=element,
                                                                                              invalid_text=invalid_text,
                                                                                              current=current_text)


def _get_element_text(context, element):
    """
    Step. Returns the text of an element, waiting if the element is not visible.

    :param context: Behave Context.
    :param element: WebElement name.
    :return Result of comparision
    """

    element = context.get_element_from_current_page(element)
    element.wait_until_visible()

    return element.text


@step(u'the text of the elements in the table contains the expected message')
def elements_from_table_contain_text(context):
    """
    Step. Assert: Checks if the given messages are contained in the text of the WebElements on the table.

    :param context: Behave Context.
    :Table Headers
    :Header element: WebElement name.
    :Header text_value: Text messsage to check
    """
    for row in context.table:
        context.execute_steps(u"""
        Then the text of the element "{element}" contains "{expected_text}"
        """.format(element=row["element"], expected_text=row["text_value"]))


@step(u'the text of the elements in the table is equal to the expected message')
def elements_from_table_equal_text(context):
    """
    Assert: Checks if the given messages are equals to the text of each Element in the table.
    Table example (from Scenario):
        | element | text_value |
        | ele1    | text1      |
        | ...     | ...        |

    Headers:
        :Header element: Element name.
        :Header text_value: Text message to check for that Element
    """
    for row in context.table:
        context.execute_steps(u"""
            Then the text of the element "{element}" is equal to "{expected_text}"
        """.format(element=row["element"], expected_text=row["text_value"]))


@step(u'the text in "{current_element}" element matches the value previously saved in "{previous_element}" element')
def check_value_filled(context, current_element, previous_element):
    """
    Step. Assert. Checks if the text of a WebElement is equal to the filled in a form field.
    :param current_element: WebElement name to get its text value (current page)
    :param previous_element: WebElement name of a previous filled value in web form.
        All values filled in a form are saved in context.filled_values and can be retrieved afterwards to
        validate results.
    """

    element = context.get_element_from_current_page(current_element)

    assert previous_element in context.filled_values, \
        u"The field with name %s has not been filled in previously" % previous_element

    expected_value = context.filled_values[previous_element]
    assert expected_value == element.text


@step(u'the text of the elements in the table matches the value previously saved')
def elements_from_table_values_filled(context):
    """
    Assert: Checks if the text of the given Element is equal to the filled in a previous form field element.
    Table example (from Scenario):
        | element | text_value |
        | ele1    | text1      |
        | ...     | ...        |

    Parameters:
        Table element: Element name to get its text value (current page)
        Table previous_element: Element name of a previous filled value in web form.
            All filled values in a form are saved in context.filled_values.
    """
    for row in context.table:
        context.execute_steps(u"""
            Then the text in "{element}" element matches the value previously saved in "{previous_element}" element
        """.format(element=row["element"], previous_element=row["previous_element"]))


@step(u'the selected option of the element "{element}" is equal to "{value}"')
def element_of_selector_is_equal_to(context, element, value):
    """
    the selected option of the element "element" is equal to "value"

    Step. Compares the actual value of a selector element
    :param context: Behave Context.
    :param element: WebElement name.
    :param value: value to check as selected option
    :return: None
    """

    element = context.get_element_from_current_page(element)

    selected_option = element.option

    assert selected_option == value, \
        "Expected: {}; Value: {}".format(value, selected_option)


@step(u'the "{element}" element is disabled')
@step(u'the "{element}" button is disabled')
def element_is_disabled(context, element):
    """
    Asserts the element is disabled

    :param context: Behave Context.
    :param element: WebElement name
    """
    assert not context.get_element_from_current_page(element).web_element.is_enabled(), \
        u'Element {element} is enabled, disabled expected'.format(element=element)


@step(u'the "{element}" element is enabled')
@step(u'the "{element}" button is enabled')
def element_is_enabled(context, element):
    """
    Asserts the element is enabled

    :param context: Behave context
    :param element: WebElement name
    """
    assert context.get_element_from_current_page(element).web_element.is_enabled(), \
        u'Element {element} is disabled, enabled expected'.format(element=element)


@step(u'the text of the element "{element}" matches regexp "{expected_regexp}"')
def element_matches_regexp(context, element, expected_regexp):
    """
    Step. Assert: Checks if the given regular expression matches the text of the WebElement.

    :param context: Behave Context.
    :param element: WebElement name.
    :param expected_regexp: Regular expression to check.
    """

    element = context.get_element_from_current_page(element)
    element.wait_until_visible()

    assert re.search(expected_regexp, element.text), \
        "Expected regexp: {}; received: {}".format(expected_regexp, element.text)


@step(u'the downloaded file "{file_name}" is equal to the expected file in "{expected_folder}"')
@step(u'the downloaded file "{file_name}" is equal to the expected file in "{expected_folder}"'
      u' waiting until "{max_wait:d}" seconds')
def step_impl(context, file_name, expected_folder, max_wait=10):
    compare_downloaded_file(context, file_name, expected_folder, max_wait)


@step(u'the element "{element}" has attribute "{attribute}" with value "{value}"')
def element_has_attribute(context, element, attribute, value):
    """
    Asserts an element has an attribut with specific value

    :param context:     Toolium context
    :param element:     Target element
    :param attribute:   Attribute to get value
    :param value:       Expected value of attribute
    """

    web_element = context.get_element_from_current_page(element).web_element

    attr_value = web_element.get_attribute(attribute)

    assert attr_value is not None, \
        u'The element "{element}" does not contain the "{attribute}" attribute'\
        .format(element=element, attribute=attribute)

    assert value == attr_value, \
        u'The attribute "{attribute}" of element "{element}" has value "{attr_val}", but "{value}" was expected'\
        .format(attribute=attribute, element=element, attr_val=attr_value, value=value)


@step(u'the element "{element}" not has attribute "{attribute}" with value "{value}"')
def element_not_has_attribute(context, element, attribute, value):
    """
    Asserts an element doesn't have an attribute with specific value

    :param context:     Toolium context
    :param element:     Target element
    :param attribute:   Attribute to get value
    :param value:       Expected value of attribute
    """

    web_element = context.get_element_from_current_page(element).web_element

    attr_value = web_element.get_attribute(attribute)
    if attr_value:
        assert value != attr_value, \
            u'The attribute "{attribute}" of element "{element}" has value "{value}", but it was not expected.' \
            .format(attribute=attribute, element=element, value=value)


@step(u'the element "{element}" has class "{clazz}"')
def element_has_class(context, element, clazz):
    """
    Asserts an element has a class

    :param context: Toolium context
    :param element: Target element
    :param clazz:   Class to find
    """

    web_element = context.get_element_from_current_page(element).web_element

    clazz_value = web_element.get_attribute("class")

    assert clazz_value is not None, \
        u'The element "{element}" does not contain the "class" attribute.'\
        .format(element=element)

    assert clazz in clazz_value.split(" "), \
        u'The element "{element}" does not have class "{clazz}", but it contains "{clazz_value}"' \
        .format(element=element, clazz=clazz, clazz_value=clazz_value)


@step(u'the element "{element}" not has class "{clazz}"')
def element_not_has_class(context, element, clazz):
    """
    Asserts an element doesn't have a class

    :param context: Toolium context
    :param element: Target element
    :param clazz:   Class to find
    """

    web_element = context.get_element_from_current_page(element).web_element

    clazz_value = web_element.get_attribute("class")
    if clazz_value:
        assert clazz not in clazz_value.split(" "), \
            u'The element "{element}" contains the class "{clazz}", but it was not expected.'\
            .format(element=element, clazz=clazz)


@step(u'the text of the alert is equal to "{expected_message}"')
@step(u'the text of the alert is equal to "{expected_message}" with params')
def alert_equal_text(context, expected_message):
    """
    Step. Assert: Checks if the given message is equal to the text of the alert.

    :param context: Behave Context.
    :param expected_message: Text message to check.
    """
    expected_message = _format_text(context, expected_message)
    element = context.driver.switch_to.alert

    assert element.text == expected_message


@step(u'the value of all column "{column_index:d}" cells of table "{table}" contains "{text}"')
@step(u'the value of all column index "{column_index:d}" cells of table "{table}" contains "{text}"')
def column_cell_text_is(context, column_index, table, text):
    """
    Step. Assert: Check all cells in the specified column index contains the text

    :param context: Behave context
    :param column_index: column index
    :param table: table element
    :param text: expected text
    """
    rows = context.get_element_from_current_page(table).web_element.find_elements(By.TAG_NAME, u'tr')

    for tr in rows:
        cell_text = tr.find_elements(By.TAG_NAME, 'td')[column_index].text

        assert text in cell_text, \
            'The row does not contain the text "{text}". Current value: "{current}"'.format(text=text,
                                                                                            current=cell_text)


@step(u'the value of all column "{column_index:d}" cells of table "{table}" does not contain "{text}"')
@step(u'the value of all column index "{column_index:d}" cells of table "{table}" does not contain "{text}"')
def column_cell_text_is_not(context, column_index, table, text):
    """
    Step. Assert: Check all cells in the specified column index does not contain the text

    :param context: Behave context
    :param column_index: column index
    :param table: table element
    :param text: expected text
    """
    rows = context.get_element_from_current_page(table).web_element.find_elements(By.TAG_NAME, u'tr')

    for tr in rows:
        cell_text = tr.find_elements(By.TAG_NAME, 'td')[column_index].text

        assert text not in cell_text, \
            'The row contains the text "{text}". Current value: "{current}"'.format(text=text, current=cell_text)


@step(u'the attribute "{attribute}" value for element "{element_name}" is "{expected}"')
def check_attribute_value_is(context, attribute, element_name, expected):
    """
    Compare the value from a attribute of an element

    :param context: Behave context
    :param attribute: Element's attribute
    :param element_name: PageElement
    :param expected: expected value
    """
    result, attribute_value = _check_attribute_value(context, attribute, element_name, expected)

    assert result, u'Unexpected value on {element}@{attribute}: {value}'.format(
        element=element_name, attribute=attribute, value=attribute_value)


@step(u'the attribute "{attribute}" value for element "{element_name}" is not "{expected}"')
def check_attribute_value_is_not(context, attribute, element_name, expected):
    """
    Compare the value from a attribute of an element

    :param context: Behave context
    :param attribute: Element's attribute
    :param element_name: PageElement
    :param expected: unexpected value
    """
    result, attribute_value = _check_attribute_value(context, attribute, element_name, expected)

    assert not result, u'The value on {element}@{attribute} is {value}. This is an unexpected value'.format(
        element=element_name, attribute=attribute, value=attribute_value)


def _check_attribute_value(context, attribute, element_name, expected):
    """
    Compare the value from a attribute of an element

    :param context: Behave context
    :param attribute: Element's attribute
    :param element_name: PageElement
    :param expected: expected value
    :return: Result of comparision
    """
    element = context.get_element_from_current_page(element_name)

    if isinstance(element, Tag):
        attribute_value = element.get(attribute)
    else:
        attribute_value = element.get_attribute(attribute)

    return attribute_value == expected, attribute_value


@step(u'the amount of tag elements "{element_tag}" in element "{container_element}" is "{expected:d}"')
def amount_of_tags_in_element_is(context, element_tag, container_element, expected):
    """
    Step. Assert: Checks if the amount of the specified kind of tags of an elements is a desired value

    :param context: Behave context
    :param element_tag: HTML tag name
    :param container_element: element which contains the tags
    :param expected: Expected amount of tags
    """
    result, tags_found = _compare_amount_of_tags_in_element(context, element_tag, container_element, expected)

    assert result == 0, \
        u'The amount of "{element_tag}" tags in element "{element}" should be "{expected}", but found "{found}".' \
        .format(element_tag=element_tag, element=container_element, expected=expected, found=tags_found)


@step(u'the amount of tag elements "{element_tag}" in element "{container_element}" is not "{expected:d}"')
def amount_of_tags_in_element_is_not(context, element_tag, container_element, expected):
    """
    Step. Assert: Checks if the amount of the specified kind of tags of an elements is not a desired value

    :param context: Behave context
    :param element_tag: HTML tag name
    :param container_element: element which contains the tags
    :param expected: Expected amount of tags
    """
    result, tags_found = _compare_amount_of_tags_in_element(context, element_tag, container_element, expected)

    assert result != 0, \
        u'The amount of "{element_tag}" tags in element "{element}" should not be "{found}".'.format(
            element_tag=element_tag, element=container_element, found=tags_found)


@step(u'the amount of tag elements "{element_tag}" in element "{container_element}" is greater than "{expected:d}"')
def amount_of_tags_in_element_is_greater(context, element_tag, container_element, expected):
    """
    Step. Assert: Checks if the amount of the specified kind of tags of an elements is greater than a desired value

    :param context: Behave context
    :param element_tag: HTML tag name
    :param container_element: element which contains the tags
    :param expected: Expected amount of tags
    """
    result, tags_found = _compare_amount_of_tags_in_element(context, element_tag, container_element, expected)

    assert result > 0, \
        u'The amount of "{element_tag}" tags in element "{element}" should be greater than "{expected}",' \
        u' but found "{found}".'.format(element_tag=element_tag, element=container_element, expected=expected,
                                        found=tags_found)


@step(u'the amount of tag elements "{element_tag}" in element "{container_element}" is lesser than "{expected:d}"')
def amount_of_tags_in_element_is_less(context, element_tag, container_element, expected):
    """
    Step. Assert: Checks if the amount of the specified kind of tags of an elements is lesser than a desired value

    :param context: Behave context
    :param element_tag: HTML tag name
    :param container_element: element which contains the tags
    :param expected: Expected amount of tags
    """
    result, tags_found = _compare_amount_of_tags_in_element(context, element_tag, container_element, expected)

    assert result < 0, \
        u'The amount of "{element_tag}" tags in element "{element}" should be lesser than "{expected}",' \
        u' but found "{found}".'.format(element_tag=element_tag, element=container_element, expected=expected,
                                        found=tags_found)


def _compare_amount_of_tags_in_element(context, element_tag, container_element, expected):
    """
    Step. Assert: Makes the comparision of the amount of tags in an element

    :param context: Behave context
    :param element_tag: HTML tag name
    :param container_element: element which contains the tags
    :param expected: Expected amount of tags
    :return: Result of comparision and the amount of tags found
    """
    element = context.get_element_from_current_page(container_element)

    tags_found = len(element.web_element.find_elements(By.TAG_NAME, element_tag))

    return tags_found - expected, tags_found


def _format_text(context, expected_message):
    """
    Return: Format the given string with the table values.

    :Table Headers
    :Header key:    Key to be replaced in the given string
    :Header value:  Replacement text

        Eg:
        strings >
            [LANG:hello_text] = 'Hello {name} {surname}'

        feature >
            ...
            Then  the text of the element "title" contains "[LANG:hello_text]" with params
            | key        | value               |
            | name       | [CONF:user.name]    |
            | surname    | [CONF:user.surname] |
    """
    if context.table:
        for row in context.table:
            if 'key' in row and 'value' in row:
                expected_message = expected_message.replace("{{{0}}}".format(row['key']), row['value'])

    return expected_message
